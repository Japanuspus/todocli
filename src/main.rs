use serde::{Serialize, Deserialize};
use reqwest;
use reqwest::blocking::{Client};
use std::time::{SystemTime, Duration};
use std::{io::Write, fmt};
use structopt::StructOpt;
use anyhow;

mod config; //from config.rs generated by build.rs
use config::CONFIG;


type ReqwestResult<T> = std::result::Result<T, reqwest::Error>;
type ConfyResult<T> = std::result::Result<T, confy::ConfyError>;

#[derive(Deserialize, Debug)]
struct DeviceAuthorizationResponse {
    device_code: String,
    // user_code: String,
    // verification_uri: String,
    expires_in: usize,
    interval: usize,
    message: String,
}

impl fmt::Display for DeviceAuthorizationResponse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let expected_max_retries = self.expires_in/self.interval;
        let bar = std::iter::repeat('_')
            .take(expected_max_retries)
            .take(72) // max 72 signs in line
            .collect::<String>();
        writeln!(f, "{}\n{}", self.message, bar)
    }
}

#[derive(Deserialize, Debug)]
struct TokenResponse {
    token_type: String,
    scope: String,      // Space separated strings
    expires_in: usize,  // Seconds
    access_token: String,     
    refresh_token: String, // Opaque string, Issued if the original scope parameter included offline_access.
}

#[derive(Deserialize, Debug)]
/// ProtocolError describes the expected error messages when polling for token
struct ProtocolError {
    error: String, // "authorization_pending"  if pending
    error_description: String 
}
// See argument in favor of manual errors over thiserror macros
// https://www.reddit.com/r/rust/comments/gj8inf/rust_structuring_and_handling_errors_in_2020/fqlmknt/
impl std::error::Error for ProtocolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

impl fmt::Display for ProtocolError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Poll endpoint returned error code {}: {}", self.error, self.error_description)
    }
}

enum PollResult {
    Response(TokenResponse),
    Error(ProtocolError),
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct Tokens {
    access_token: String,
    refresh_token: String,
    // id_token: String,
    access_token_expiry: Option<SystemTime>,
}

impl Tokens {
    fn is_valid(&self) -> bool {
        self.access_token_expiry.map_or(false, |exp| exp >= SystemTime::now())
    }

    fn has_refresh_token(&self) -> bool { self.access_token_expiry.is_some() }

    fn load() -> ConfyResult<Tokens> { confy::load(&CONFIG.app_name) }
        
    fn store(&self) -> ConfyResult<()> { confy::store(&CONFIG.app_name, &self) }
}

impl From<TokenResponse> for Tokens {
    fn from(token: TokenResponse) -> Self {
        let expiry = Some(
            SystemTime::now() 
            + Duration::new(token.expires_in as u64, 0));
        Self {
            access_token_expiry: expiry,
            // ..token_response  -- not working yet
            access_token: token.access_token,
            refresh_token: token.refresh_token,
        }
    }
}

fn request_device_authorization(client: &mut Client) -> ReqwestResult<DeviceAuthorizationResponse> {
    client.post("https://login.microsoftonline.com/common/oauth2/v2.0/devicecode")
        .form(&[
            ("client_id",  CONFIG.client_id),
            ("scope", CONFIG.scope)
        ])
        .send()?
        .error_for_status()?
        .json::<DeviceAuthorizationResponse>()
}

fn poll_device_authorization(client: &mut Client, auth_response: &DeviceAuthorizationResponse) -> ReqwestResult<PollResult> {
    let res = client.post("https://login.microsoftonline.com/common/oauth2/v2.0/token")
        .form(&[
            ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
            ("client_id", &CONFIG.client_id),
            ("device_code", &auth_response.device_code),
        ])
        .send()?;

    if res.status().is_success() {
        Ok(PollResult::Response(res.json::<TokenResponse>()?))
    } else {
        Ok(PollResult::Error(res.json::<ProtocolError>()?))
    }
}

/// Implement device-flow as described in [1].
/// [1]: https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code
fn obtain_new_device_auth(mut client: &mut Client) -> anyhow::Result<Tokens> {
    let request = request_device_authorization(client)?;
    println!("{}", request);
    loop {
        std::thread::sleep(Duration::new(request.interval as u64, 0));
        print!(".");
        std::io::stdout().flush().unwrap();

        match poll_device_authorization(&mut client, &request)? {
            PollResult::Response(r) => {
                break Ok(r.into());
            }
            PollResult::Error(e) => {
                if ! (e.error == "authorization_pending") {
                    Err(e)?;
                }
            }
        }
    }
}

fn refresh_token(client: &mut Client, current: &Tokens) -> ReqwestResult<Tokens> {
    client.post("https://login.microsoftonline.com/common/oauth2/v2.0/token")
        .form(&[
            ("grant_type", "refresh_token"),
            ("client_id", &CONFIG.client_id),
            ("scope", &CONFIG.scope),
            ("refresh_token", &current.refresh_token),
        ])
        .send()?
        .error_for_status()?
        .json::<TokenResponse>().map(|tr| tr.into())
}

fn get_token(client: &mut Client) -> anyhow::Result<Tokens> {
    let current = Tokens::load()?;
    let valid = if current.is_valid() {
        current
    } else if current.has_refresh_token() {
        refresh_token(client, &current)?
    } else {
        obtain_new_device_auth(client)?
    };
    valid.store()?;
    Ok(valid)
}

#[derive(Debug, Serialize)]
struct TaskSimple {
    #[serde(rename = "Subject")]
    subject: String
}

// https://docs.microsoft.com/en-us/previous-versions/office/office-365-api/api/version-2.0/task-rest-operations
// 
fn todo_add_simple(client: &mut Client, tokens: &Tokens, subject: &str) -> anyhow::Result<()> {
    client
    .post("https://outlook.office.com/api/v2.0/me/tasks")
    .bearer_auth(&tokens.access_token)
    .json(&TaskSimple{subject: subject.to_string()})
    .send()?
    .error_for_status()?;
    Ok(())
}


/// Add a task to microsoft todo
#[derive(StructOpt)]
struct Opt {
    /// The subject line of the task to add
    subject: String,
}


fn main() -> anyhow::Result<()> {
    let opt = Opt::from_args();

    let mut client = Client::new();
    let token = get_token(&mut client)?;
    todo_add_simple(&mut client, &token, &opt.subject)
}
