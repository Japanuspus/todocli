use serde::{Serialize, Deserialize};
use reqwest;
use reqwest::blocking::{Client};
use std::time::{SystemTime, Duration};
use std::{io::Write, fmt};

mod config; //from config.rs generated by build.rs
use config::CONFIG;

use anyhow;

type ReqwestResult<T> = std::result::Result<T, reqwest::Error>;

#[derive(Deserialize, Debug)]
struct DeviceAuthorizationResponse {
    device_code: String,
    // user_code: String,
    // verification_uri: String,
    expires_in: usize,
    interval: usize,
    message: String,
}

impl fmt::Display for DeviceAuthorizationResponse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let expected_max_retries = self.expires_in/self.interval;
        let bar = std::iter::repeat('_')
            .take(expected_max_retries)
            .take(72) // max 72 signs in line
            .collect::<String>();
        writeln!(f, "{}\n{}", self.message, bar)
    }
}

#[derive(Deserialize, Debug)]
struct TokenResponse {
    token_type: String,
    scope: String,      // Space separated strings
    expires_in: usize,  // Seconds
    access_token: String,     
    // id_token: String, // JWT, Issued if the original scope parameter included the openid scope.
    refresh_token: String, // Opaque string, Issued if the original scope parameter included offline_access.
}

#[derive(Deserialize, Debug)]
/// ProtocolError describes the expected error messages when polling for token
struct ProtocolError {
    error: String, // "authorization_pending"  if pending
    error_description: String 
}
// See argument in favor of manual errors over thiserror macros
// https://www.reddit.com/r/rust/comments/gj8inf/rust_structuring_and_handling_errors_in_2020/fqlmknt/
impl std::error::Error for ProtocolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

impl fmt::Display for ProtocolError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Poll endpoint returned error code {}: {}", self.error, self.error_description)
    }
}

enum PollResult {
    Response(TokenResponse),
    Error(ProtocolError),
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct Tokens {
    access_token: String,
    refresh_token: String,
    access_token_expiry: Option<SystemTime>,
}

impl From<TokenResponse> for Tokens {
    fn from(token_response: TokenResponse) -> Self {
        Self {
            access_token: token_response.access_token,
            refresh_token: token_response.refresh_token,
            access_token_expiry: Some(SystemTime::now() + Duration::new(token_response.expires_in as u64, 0))
        }
    }
}

fn request_device_authorization(client: &mut Client) -> ReqwestResult<DeviceAuthorizationResponse> {
    client.post("https://login.microsoftonline.com/common/oauth2/v2.0/devicecode")
        .form(&[
            ("client_id",  CONFIG.client_id),
            ("scope", CONFIG.scope)
        ])
        .send()?
        .error_for_status()?
        .json::<DeviceAuthorizationResponse>()
}

fn poll_device_authorization(client: &mut Client, auth_response: &DeviceAuthorizationResponse) -> ReqwestResult<PollResult> {
    let res = client.post("https://login.microsoftonline.com/common/oauth2/v2.0/token")
        .form(&[
            ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
            ("client_id", &CONFIG.client_id),
            ("device_code", &auth_response.device_code),
        ])
        .send().expect("error sending request");

    if res.status().is_success() {
        Ok(PollResult::Response(res.json::<TokenResponse>()?))
    } else {
        Ok(PollResult::Error(res.json::<ProtocolError>()?))
    }
}

/// Implement device-flow as described in [1].
/// [1]: https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-device-code
fn obtain_new_device_auth(mut client: &mut Client) -> anyhow::Result<Tokens> {
    let request = request_device_authorization(client)?;
    println!("{}", request);
    loop {
        std::thread::sleep(Duration::new(request.interval as u64, 0));
        print!(".");
        std::io::stdout().flush().unwrap();

        match poll_device_authorization(&mut client, &request)? {
            PollResult::Response(r) => {
                break Ok(r.into());
            }
            PollResult::Error(e) => {
                if ! (e.error == "authorization_pending") {
                    Err(e)?;
                }
            }
        }
    }
}

fn main() -> anyhow::Result<()> {
    let mut tokens: Tokens = confy::load(&CONFIG.app_name).expect("Failed to load tokens");
    // println!("Hello, world from {} with token: {}", CONFIG.tenant_id, tokens.access_token);

    tokens.access_token = format!("{}{}", tokens.access_token, "x");
    confy::store(&CONFIG.app_name, &tokens).expect("Failed to store tokens");

    let mut client = Client::new();
    let tokens = obtain_new_device_auth(&mut client).expect("Unable to authorize");

    confy::store(&CONFIG.app_name, &tokens).expect("Failed to store tokens");
    println!("Tokens successfully stored");

    Ok(())
}
